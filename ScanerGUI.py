# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Test.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from __future__ import annotations
from typing import *
import sys
import os
from matplotlib.backends.qt_compat import QtCore, QtWidgets
# from PyQt5 import QtWidgets, QtCore
from matplotlib.backends.backend_qt5agg import FigureCanvas
# from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
import matplotlib as mpl
import matplotlib.figure as mpl_fig
import matplotlib.animation as anim
import numpy as np
from PyQt5 import QtCore, QtGui, QtWidgets
import thorlabs_apt as apt
from ThorlabsPM100 import ThorlabsPM100
import pyvisa as visa
from functools import partial
from time import sleep



class Ui_MainWindow(object):
    def __init__(self, motor, powerMeter):
        self.motor = motor
        self.powerMeter = powerMeter
        self.interval = 1
        self.lowerBound = 0
        self.upperBound = 150
        self.filename = "test.csv"
        return
    
    def setupUi(self, MainWindow):


        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1370, 603)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")



        font = QtGui.QFont()
        font.setPointSize(36)
        font.setBold(True)
        font.setWeight(75)
        
       
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(1230, 90, 111, 61))
        
        font = QtGui.QFont()
        font.setPointSize(20)
        font.setBold(True)
        font.setWeight(75)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.UpButton = QtWidgets.QPushButton(self.centralwidget)
        self.UpButton.setGeometry(QtCore.QRect(30, 230, 121, 71))
        self.UpButton.setObjectName("UpButton")
        self.UpButton.clicked.connect(self.MoveMotorUp)

        self.HomButton = QtWidgets.QPushButton(self.centralwidget)
        self.HomButton.setGeometry(QtCore.QRect(30, 130, 121, 71))
        self.HomButton.setObjectName("HomButton")
        self.HomButton.clicked.connect(self.MoveMotorHome)

        self.DownButton = QtWidgets.QPushButton(self.centralwidget)
        self.DownButton.setGeometry(QtCore.QRect(30, 300, 121, 71))
        self.DownButton.setObjectName("DownButton")
        self.DownButton.clicked.connect(self.MoveMotorDown)


        self.SaveFilePatTextBox = QtWidgets.QTextEdit(self.centralwidget)
        self.SaveFilePatTextBox.setGeometry(QtCore.QRect(510, 490, 391, 41))
        self.SaveFilePatTextBox.setObjectName("SaveFilePatTextBox")
        self.SavePathText = QtWidgets.QLabel(self.centralwidget)
        self.SavePathText.setGeometry(QtCore.QRect(510, 470, 171, 16))
        self.SaveFilePatTextBox.textChanged.connect(self.SaveFilePathChanged)
        
        font = QtGui.QFont()
        font.setPointSize(14)
        self.SavePathText.setFont(font)
        self.SavePathText.setObjectName("SavePathText")
        self.checkBox = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox.setGeometry(QtCore.QRect(430, 500, 70, 17))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.checkBox.setFont(font)
        self.checkBox.setObjectName("checkBox")
        self.Displayframe = QtWidgets.QFrame(self.centralwidget)
        self.Displayframe.setGeometry(QtCore.QRect(330, 40, 791, 391))
        self.Displayframe.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.Displayframe.setFrameShadow(QtWidgets.QFrame.Raised)
        self.Displayframe.setObjectName("Displayframe")

        # 2. Place the matplotlib figure
        self.lyt = QtWidgets.QVBoxLayout()
        self.Displayframe.setLayout(self.lyt)
        #Data Being Pulled From a File
        y_range = [0, .0000050]
        self.myFig = CollectedDataCanvas(x_range=[self.lowerBound, self.upperBound],y_range = y_range,  interval=20, title = "Collected Data", filename = self.filename)
        self.lyt.addWidget(self.myFig)
        
        #Live Reading
        self.myFig2 = RealTimeDataCanvas(x_len=200, y_range=y_range, interval=20, title = "RealTime" , powerMeter = self.powerMeter)
        self.lyt.addWidget(self.myFig2)

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1370, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        #Interval Box
        self.MovementIntervalspinBox = QtWidgets.QSpinBox(self.centralwidget)
        self.MovementIntervalspinBox.setGeometry(QtCore.QRect(1260, 160, 81, 51))
        self.MovementIntervalspinBox.setFont(font)
        self.MovementIntervalspinBox.setObjectName("MovementIntervalspinBox")
        self.MovementIntervalspinBox.setRange(1, 150)
        self.MovementIntervalspinBox.setValue(self.interval)
        self.MovementIntervalspinBox.valueChanged.connect(self.MovementIntervalChanged)


        self.LowerBoundspinBox = QtWidgets.QSpinBox(self.centralwidget)
        self.LowerBoundspinBox.setGeometry(QtCore.QRect(1200, 351, 71, 51))
        self.LowerBoundspinBox.setObjectName("LowerBoundBox")
        self.LowerBoundspinBox.setRange(0, 150)
        self.LowerBoundspinBox.setValue(self.lowerBound)
        self.LowerBoundspinBox.valueChanged.connect(self.LowerBoundspinBoxChanged)

        self.UpperBoundspinBox = QtWidgets.QSpinBox(self.centralwidget)
        self.UpperBoundspinBox.setGeometry(QtCore.QRect(1270, 350, 71, 51))
        self.UpperBoundspinBox.setObjectName("UpperBoundBox")
        self.UpperBoundspinBox.setRange(1, 150)
        self.UpperBoundspinBox.setValue(self.upperBound)
        self.UpperBoundspinBox.valueChanged.connect(self.UpperBoundspinBoxChanged)



        self.LowerBoundText = QtWidgets.QLabel(self.centralwidget)
        self.LowerBoundText.setGeometry(QtCore.QRect(1200, 320, 71, 41))
        self.LowerBoundText.setObjectName("LowerBoundText")
        self.UpperBoundText = QtWidgets.QLabel(self.centralwidget)
        self.UpperBoundText.setGeometry(QtCore.QRect(1270, 330, 71, 21))
        self.UpperBoundText.setObjectName("UpperBoundText")
        
        #Scan Button Functionality
        self.ScanButton = QtWidgets.QPushButton(self.centralwidget)
        self.ScanButton.setGeometry(QtCore.QRect(1200, 220, 141, 81))
        self.ScanButton.setObjectName("ScanButton")
        self.ScanButton.clicked.connect(lambda: self.Scan(self.lowerBound, self.upperBound, self.interval,self.motor, self.powerMeter, self.filename, self.myFig))

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.ScanButton.setText(_translate("MainWindow", "Scan"))
        self.label.setText(_translate("MainWindow", "Scan \n"
"Interval"))
        self.UpButton.setText(_translate("MainWindow", "Up"))
        self.HomButton.setText(_translate("MainWindow", "Home"))
        self.DownButton.setText(_translate("MainWindow", "Down"))
        self.SavePathText.setText(_translate("MainWindow", "Save File Path"))
        self.checkBox.setText(_translate("MainWindow", "Save"))
        self.LowerBoundText.setText(_translate("MainWindow", "Lower Bound"))
        self.UpperBoundText.setText(_translate("MainWindow", "Upper Bound"))

    #Update the interval for the Scan
    def MovementIntervalChanged(self):
        self.interval = self.MovementIntervalspinBox.value()
        return
    def LowerBoundspinBoxChanged(self):
        self.lowerBound = self.LowerBoundspinBox.value()
        return
    def UpperBoundspinBoxChanged(self):
        self.upperBound = self.UpperBoundspinBox.value()
        return

    def MoveMotorDown(self):
        self.motor.move_by(self.interval)
        print(self.motor.position)
        return

    def MoveMotorUp(self):
        self.motor.move_by(-self.interval)
        print(self.motor.position)
        return
        
    def MoveMotorHome(self):
        self.motor.move_home(blocking=True)
        print(self.motor.position)
        return


    def SaveFilePathChanged(self):
        self.filename = self.SaveFilePatTextBox.toPlainText()
        self.lyt.removeWidget(self.myFig)
        self.myFig.deleteLater()
        self.myFig = None
        self.myFig = CollectedDataCanvas(x_range=[self.lowerBound, self.upperBound], interval=20, title = "Collected Data", filename = self.filename)
        self.lyt.addWidget(self.myFig)
        
        return

#Scan Function:
#Scans from the lower bound to the upper bound in intervals of the interval.
#Saves the Data to the Save File
#Figure parameter is an attempt to update the Figure after each scan
    def Scan(self, begin, end, interval, motor, powerMeter, saveFile, figure):
        open('saveFile', 'w').close()
        motor.move_to(begin, blocking=True)
        for i in range(begin,end,interval):
            motor.move_to(i, blocking = False)
            while( round(motor.position,2) != round(i,2)):
                print(round(motor.position,2))
                sleep(1) #wait for the motor to move
            
            with open(saveFile, "a+") as f:
                f.write(f"{motor.position},{powerMeter.read}\n") 
                f.close()
            
            figure._update_canvas_(i, saveFile)       
        
        return


#Create a plot for the realtime Data
class RealTimeDataCanvas(FigureCanvas, anim.FuncAnimation):
    '''
    This is the FigureCanvas in which the live plot is drawn.

    '''
    def __init__(self, x_len:int, y_range:List, interval:int, title:str, powerMeter) -> None:
        '''
        :param x_len:       The nr of data points shown in one plot.
        :param y_range:     Range on y-axis.
        :param interval:    Get a new datapoint every .. milliseconds.

        '''
        FigureCanvas.__init__(self, mpl_fig.Figure())
        # Range settings
        self._x_len_ = x_len
        self._y_range_ = y_range

        # Store two lists _x_ and _y_
        x = list(range(0, x_len))
        y = [0] * x_len

        # Store a figure and ax
        self._ax_  = self.figure.subplots()
        self._ax_.set_ylim(ymin=self._y_range_[0], ymax=self._y_range_[1])
        self._line_, = self._ax_.plot(x, y)
        self._ax_.set_title(title)
        self._ax_.set_xlabel('Time [20mS]')
        self._ax_.set_ylabel('Intensity')
        
        
        # Call superclass constructors
        anim.FuncAnimation.__init__(self, self.figure, self._update_canvas_, fargs=(y,powerMeter), interval=interval, blit=True)
        return

    def _update_canvas_(self, i, y, powerMeter) -> None:
        '''
        This function gets called regularly by the timer.

        '''
        y.append(get_next_datapoint(powerMeter))     # Add new datapoint
        y = y[-self._x_len_:]              # Truncate list _y_
        self._line_.set_ydata(y)
        self._ax_.relim()
        return self._line_,


#Create a plot of the Saved Data
class CollectedDataCanvas(FigureCanvas, anim.FuncAnimation):
    '''
    This is the FigureCanvas in which the live plot is drawn.

    '''
    def __init__(self, x_range:List,y_range:List, interval:int, title:str, filename:str) -> None:
        '''
        :param x_len:       The nr of data points shown in one plot.
        :param y_range:     Range on y-axis.
        :param interval:    Get a new datapoint every .. milliseconds.

        '''
        FigureCanvas.__init__(self, mpl_fig.Figure())
        # Range settings
        self._x_range_ = x_range
        self._y_range_ = y_range
        # Store two lists _x_ and _y_
        x = list(range(x_range[0], x_range[1]))
        y = [0] * x_range[1]

        # Store a figure and ax
        self._ax_  = self.figure.subplots()
        self._ax_.set_xlim(xmin=self._x_range_[0], xmax=self._x_range_[1])
        self._ax_.set_ylim(ymin=self._y_range_[0], ymax=self._y_range_[1])
        self._line_, = self._ax_.plot(x, y)
        self._ax_.set_title(title)
        self._ax_.set_xlabel('Position [mm]')
        self._ax_.set_ylabel('Intensity')
        # Call superclass constructors
        anim.FuncAnimation.__init__(self, self.figure, self._update_canvas_, fargs=(filename,), interval=interval, blit=False)
        return

    #read the Data File
    def _update_canvas_(self, i, filename) -> None:
        '''
        This function gets called regularly by the timer.

        '''

        with open(f"{filename}", 'r') as f:
            data= f.readlines()
        
        xar = []
        yar = []
        for eachLine in data:
            if len(eachLine)>1:
                x,y = eachLine.split(',')
                xar.append(float(x))
                yar.append(float(y.strip('\n')))
        #self._ax_.plot(xar, yar) # possible alternative
        self._line_.set_ydata(yar)
        self._line_.set_xdata(xar)
        self._ax_.relim()
        return self._line_,




def get_next_datapoint(powerMeter):
    return powerMeter.read


#Scan Given the Parameters
def Scan(begin, end, interval, motor, powerMeter, saveFile, figure):
    open('saveFile', 'w').close()
    motor.move_to(begin, blocking=True)
    for i in range(begin,end,interval):
        motor.move_to(i, blocking = False)
        while( round(motor.position,2) != round(i,2)):
            print(round(motor.position,2))
            sleep(1) #wait for the motor to move
        
        with open(saveFile, "a+") as f:
            f.write(f"{motor.position},{powerMeter.read}\n") 
            f.close()
        
        figure._update_canvas_(i, saveFile)       
    
    return


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    

    
    motor = apt.Motor(45822683) #initialize motor by serial number
    
    #motor = None
    #For the Power Meter
    rm = visa.ResourceManager()
    rm.list_resources()
    inst = rm.open_resource('USB0::0x1313::0x8075::P5003438::INSTR', read_termination='\\n', timeout=1)
    power_meter = ThorlabsPM100(inst=inst)
    print(power_meter.read)
    ui = Ui_MainWindow(motor, power_meter)
    ui.setupUi(MainWindow)


    
    MainWindow.show()
    sys.exit(app.exec_())
